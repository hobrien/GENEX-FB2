from os import path
configfile: "config.yaml"


rule all:
    input:
        results = expand("results/{level}_{gwas}.results", level = ['gene', 'transcript'], gwas=config['gwas']),
        
rule download_ref:
    params:
        url = lambda wildcards: config['downloads'][wildcards.download],
        file = lambda wildcards: path.basename(config['downloads'][wildcards.download])
    output:
        "Reference/{download}"
    shell:
        "cd Reference; "
        "curl -O -L {params.url}; "
        "tar -xzf {params.file}"

"""this one is treated separately because it does not need to be uncompressed"""
rule download_sumstats:
    params:
        url = config['scz_sumstats'],
    output:
        path.basename(config['scz_sumstats'])
    shell:
        "curl -O -L {params.url}"

""" - since we have a rule to create the folder but not the files, I think the solution is
to put the folder in the input of the rules and the files in the params

    - ancient() is used because I modified the contents of the baseline folder which changes the timestamp
    - I've since refactored things so none of the Reference folders are modified
"""
rule annot2bed:
    input:
        folder = ancient("Reference/baseline"),
    params:
        file = "Reference/baseline/baseline.{chr}.annot.gz"
    output:
        "annotation/baseline.{chr}_no_head.bed"
    shell:
        "zcat {params.file} | tail -n +2 | awk -v OFS=\"\t\" '{{print \"chr\"$1, $2-1, $2, $3, $4}}' "
        "| sort -k1,1 -k2,2n > {output}"

""" - need to munge bedfile so it works with CrossMap:
        - max 12 columns
        - must have strand in 6th column (in addition to chr, start and end in first 3)
    - this awk command prints these, plus the SNP and gene
    - I could keep things like p-values if I wanted to (up to 6 additional columns)
"""

rule make_bed:
    input:
         eqtls = lambda wildcards: expand("../FastQTL/sig_eqtls_{level}.{chunk}.gz", level = wildcards.level, chunk=range(1,101)),
         snp_pos = "../Genotypes/Combined/snp_positions.txt"
    output:
        "eqtls/sig_eqtls_{level}.bed.gz"
    run:
        import gzip

        # store snp positions
        with open(input['snp_pos'], 'r') as snp_pos_file:
            snp_positions = {}
            for line in snp_pos_file.readlines():
                line = line.strip()
                fields = line.split('\t')
                snp_positions[fields[2]] = ('chr' + fields[0], str(int(fields[1])-1), fields[1])

        # print all SNPs for egenes with p_val below threshold 
        with gzip.open(output[0], 'wt') as out_file:
          for input_file in input['eqtls']:
            with gzip.open(input_file, 'rt') as eqtl_file:
                for line in eqtl_file.readlines():
                    line = line.strip()
                    fields = line.split('\t')
                    out_file.write('\t'.join(snp_positions[fields[1]] + (fields[1], fields[0], '+', fields[6]))+'\n')

# remove eQTLs in 17q21 (HsInv0573 in http://invfestdb.uab.cat/index.php)
rule filter_bed:
    input:
        rules.make_bed.output
    output:
        "eqtls/sig_eqtls_{level}.filter.bed.gz"
    shell:
        "bedtools subtract -a {input} -b <(echo -e \"chr17\t45495836\t46707123\") | gzip > {output}"
        
rule liftover_sig_eqtls:
    input:
        rules.filter_bed.output,
    params:
        chain_file=config["chain_file"],
    output:
        "eqtls/sig_eqtls_{level}_hg19.bed"
    shell:
        "CrossMap.py bed {params.chain_file} <( zcat {input} | awk -v OFS=\"\t\" "
        "'{{print $1,$2,$3,$10,$4,\"+\"}}') {output}"

rule intersect_eqtls:
    input:
        annot = rules.annot2bed.output,
        eqtls = rules.liftover_sig_eqtls.output
    output:
        "annotation/sig_eqtls.{level}.{chr}.annot.gz"
    params:
        uncompressed = "annotation/sig_eqtls.{level}.{chr}.annot"
    shell:
        "echo -e \"CHR\tBP\tSNP\tCM\teqtls\" > {params.uncompressed}; "
        "/share/apps/bedtools intersect -a {input.annot} -b {input.eqtls} -c | "
        "sed 's/^chr//g' | awk -v OFS=\"\t\" '{{print $1, $2, $4, $5, $6}}' >> {params.uncompressed}; "
        "gzip {params.uncompressed}"

rule prepare_sumstats:
    input:
        lambda wildcards: config['gwas'][wildcards.gwas]
    output:
        "gwas/{gwas}.sumstats.gz"
    params:
        prefix = "gwas/{gwas}",
        #n = lambda wildcards: config['sample_size'][wildcards.gwas]
    shell:
       "~/anaconda2/bin/python ~/bin/munge_sumstats.py --sumstats {input} --out {params.prefix} " #--N {params.n}"
       
rule ldsr:
    input:
        annot = rules.intersect_eqtls.output,
        bfile_folder = "Reference/1000G_plinkfiles",
        snps_folder = "Reference/hapmap3_snps"
    output:
        "annotation/sig_eqtls.{level}.{chr}.l2.ldscore.gz"
    conda:
        "env/py27.yaml"
    params:
        bfile = "Reference/1000G_plinkfiles/1000G.mac5eur.{chr}",
        ldscores = "annotation/sig_eqtls.{level}.{chr}",
        snps = "Reference/hapmap3_snps/hm.{chr}.snp"
    log:
        "Logs/LDSC/{chr}_ldsc.txt"
    shell:
        "(ldsc.py --l2 --bfile {params.bfile} --ld-wind-cm 1 --annot {input.annot} "
        "--out {params.ldscores} --print-snps {params.snps}) 2> {log}"

rule partition_heritability:
    input:
        sumstats = "gwas/{gwas}.sumstats.gz",
        partition_lds = lambda wildcards: expand("annotation/sig_eqtls.{level}.{chr}.l2.ldscore.gz", level=wildcards.level, chr=range(1,23)),
        weights_folder = "Reference/weights_hm3_no_hla",
        freq_folder = "Reference/1000G_frq"
    output:
        "results/{level}_{gwas}.results"
    conda:
        "env/py27.yaml"
    params:
        baseline = "Reference/baseline/baseline.",
        partition = "annotation/sig_eqtls.{level}.",
        weights = "Reference/weights_hm3_no_hla/weights.",
        freq = "Reference/1000G_frq/1000G.mac5eur.",
        out = "results/{level}_{gwas}"
    shell:
        "ldsc.py --h2 {input.sumstats} --ref-ld-chr {params.baseline},{params.partition} "
        "--w-ld-chr {params.weights} --overlap-annot --frqfile-chr {params.freq} "
        "--out {params.out} --print-coefficients"
        