from os import path, chdir
import subprocess
configfile: "config.yaml"

# unpack dict of lists using nested list comprehension (see 
# https://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python
# for list of lists version)
urls = [item for sublist in config['annotations'].values() for item in sublist]

# make dict with urls as keys and urls as values using dict comprehension
# (file name it string after last back-slash in url)
downloads = {key:value for (key, value) in [(x.split('/')[-1], x) for x in urls]}

rule all:
    input:
        #results = expand("results/both_q{fdr}_{gwas}.results", fdr=['05', '01', '001', '0001'], gwas=config['gwas']),
        results = expand("results/baseline_q{fdr}_{gwas}_p.txt", fdr='05', gwas=['gene', 'transcript']),
        
        
# rule download_ref:
#     params:
#         url = lambda wildcards: config['downloads'][wildcards.download],
#         file = lambda wildcards: path.basename(config['downloads'][wildcards.download])
#     output:
#         "Reference/{download}"
#     shell:
#         "cd Reference; "
#         "curl -O -L {params.url}; "
#         "tar -xzf {params.file}"

"""this one is treated separately because it does not need to be uncompressed"""
rule download_sumstats:
    params:
        url = config['scz_sumstats'],
    output:
        path.basename(config['scz_sumstats'])
    shell:
        "curl -O -L {params.url}"

rule download_fetal:
    output:
        "Reference/raw/{filename}"
    params:
        filename="{filename}",
    run:
        chdir("Reference/raw")
        print(' '.join(["curl", "-O", "-L", downloads[params['filename']]]))
        subprocess.call(["curl", "-O", "-L", downloads[params['filename']]])
        chdir("../")


rule intersect_fetal:
    input:
        lambda wildcards: expand("Reference/raw/{bed_file}", bed_file =[x.split('/')[-1] for x in config['annotations'][wildcards.mark]])
    output:
        "Reference/fetal/{mark}.bed.gz"
    shell:
        "zcat {input} | cut -f1-4 | sort -k 1,1 -k2,2n | /share/apps/bedtools merge -i stdin | gzip > {output}"


""" - since we have a rule to create the folder but not the files, I think the solution is
to put the folder in the input of the rules and the files in the params

    - ancient() is used because I modified the contents of the baseline folder which changes the timestamp
    - I've since refactored things so none of the Reference folders are modified
"""
rule annot2bed:
    input:
        folder = ancient("Reference/baseline"),
    params:
        file = "Reference/baseline/baseline.{chr}.annot.gz"
    output:
        "annotation/baseline.{chr}_no_head.bed"
    shell:
        "zcat {params.file} | tail -n +2 | awk -v OFS=\"\t\" '{{print \"chr\"$1, $2-1, $2, $3, $4}}' "
        "| sort -k1,1 -k2,2n > {output}"

""" - need to munge bedfile so it works with CrossMap:
        - max 12 columns
        - must have strand in 6th column (in addition to chr, start and end in first 3)
    - this awk command prints these, plus the SNP and gene
    - I could keep things like p-values if I wanted to (up to 6 additional columns)
"""

rule make_bed:
    input:
         eqtls = lambda wildcards: expand("../FastQTL/sig_eqtls_{level}.{chunk}_q{fdr}.gz", level = wildcards.level, fdr=wildcards.fdr, chunk=range(1,101)),
         snp_pos = "../Genotypes/Combined/snp_positions.txt"
    output:
        "eqtls/sig_eqtls_{level}_q{fdr}.bed.gz"
    run:
        import gzip

        # store snp positions
        with open(input['snp_pos'], 'r') as snp_pos_file:
            snp_positions = {}
            for line in snp_pos_file.readlines():
                line = line.strip()
                fields = line.split('\t')
                snp_positions[fields[2]] = ('chr' + fields[0], str(int(fields[1])-1), fields[1])

        # print all SNPs for egenes with p_val below threshold 
        with gzip.open(output[0], 'wt') as out_file:
          for input_file in input['eqtls']:
            with gzip.open(input_file, 'rt') as eqtl_file:
                for line in eqtl_file.readlines():
                    line = line.strip()
                    fields = line.split('\t')
                    out_file.write('\t'.join(snp_positions[fields[1]] + (fields[1], fields[0], '+', fields[6]))+'\n')

# remove eQTLs in 17q21 (HsInv0573 in http://invfestdb.uab.cat/index.php)
rule filter_bed:
    input:
        rules.make_bed.output
    output:
        "eqtls/sig_eqtls_{level}_q{fdr}.filter.bed.gz"
    shell:
        "/share/apps/bedtools subtract -a {input} -b <(printf \"%s\\t%s\\t%s\\n\" chr17 45495836 46707123) | gzip > {output}"
        
rule liftover_sig_eqtls:
    input:
        rules.filter_bed.output,
    params:
        chain_file=config["chain_file"],
    output:
        "eqtls/sig_eqtls_{level}_q{fdr}_hg19.bed"
    shell:
        "CrossMap.py bed {params.chain_file} <( zcat {input} | awk -v OFS=\"\t\" "
        "'{{print $1,$2,$3,$10,$4,\"+\"}}') {output}"

"""this pipes together a shedload of bedtools intersect -c commands to add columns for
presence/absence of SNPs in each of the fetal annotations
It then converts from bed format to tabular by removing the (zero-based) start position for each interval,
removes 'chr' from the chromosome names, and compresses the output"""

rule intersect_marks:
    input:
        baseline = rules.annot2bed.output,
        fetal_annotations = expand("Reference/fetal/{mark}.bed.gz", mark=config['annotations'])
    output:
        "annotation/fetal_marks.{chr}.annot.gz"
    params:
        uncompressed = "annotation/fetal_marks.{chr}.annot"
    run:
            header = '\t'.join(['CHR', 'BP', 'SNP', 'CM'] + [path.basename(x).split('.')[0] for x in input['fetal_annotations']])
            subprocess.call(' '.join(['echo ' + header, '>', params['uncompressed']]), shell=True)
            command = ['/share/apps/bedtools', 'intersect', '-a', input['baseline'][0], '-b', input['fetal_annotations'][0], '-c']
            for annotation in input['fetal_annotations'][1:]:
                command = command + ['|', '/share/apps/bedtools', 'intersect', '-a', 'stdin', '-b', annotation, '-c']
            command = command + ['|', 'sed', "'s/^chr//g'"]
            command = command + ['|', 'cut', '-f', '2', '--complement', '>>', params['uncompressed']]
            print(' '.join(command))
            subprocess.call(' '.join(command), stdin=subprocess.PIPE, shell=True)
            subprocess.call(['gzip', params['uncompressed']])

rule prepare_sumstats:
    input:
        lambda wildcards: config['gwas'][wildcards.gwas]
    output:
        "gwas/{gwas}.sumstats.gz"
    params:
        prefix = "gwas/{gwas}",
        n = 120
    shell:
       "~/anaconda2/bin/python ~/bin/munge_sumstats.py --sumstats {input} --out {params.prefix} --N {params.n}"
       
rule ldsr:
    input:
        annot = rules.intersect_marks.output,
        bfile_folder = "Reference/1000G_plinkfiles",
        snps_folder = "Reference/hapmap3_snps"
    output:
        "annotation/fetal_marks.{chr}.l2.ldscore.gz"
    conda:
        "env/py27.yaml"
    params:
        bfile = "Reference/1000G_plinkfiles/1000G.mac5eur.{chr}",
        ldscores = "annotation/fetal_marks.{chr}",
        snps = "Reference/hapmap3_snps/hm.{chr}.snp"
    log:
        "Logs/LDSC/{chr}_ldsc.txt"
    shell:
        "(ldsc.py --l2 --bfile {params.bfile} --ld-wind-cm 1 --annot {input.annot} "
        "--out {params.ldscores} --print-snps {params.snps}) 2> {log}"

rule partition_heritability:
    input:
        sumstats = "gwas/{gwas}.sumstats.gz",
        partition_lds = lambda wildcards: expand("annotation/fetal_marks.{chr}.l2.ldscore.gz", fdr=wildcards.fdr, chr=range(1,23)),
        weights_folder = "Reference/weights_hm3_no_hla",
        freq_folder = "Reference/1000G_frq"
    output:
        "results/baseline_q{fdr}_{gwas}.results"
    conda:
        "env/py27.yaml"
    params:
        baseline = "Reference/baseline/baseline.",
        partition = "annotation/fetal_marks.",
        weights = "Reference/weights_hm3_no_hla/weights.",
        freq = "Reference/1000G_frq/1000G.mac5eur.",
        out = "results/baseline_q{fdr}_{gwas}"
    shell:
        "ldsc.py --h2 {input.sumstats} --ref-ld-chr {params.baseline},{params.partition} "
        "--w-ld-chr {params.weights} --overlap-annot --frqfile-chr {params.freq} "
        "--out {params.out} --print-coefficients"

rule add_pvalues: # convert Z-scores to p-values
    input:
        rules.partition_heritability.output
    output:
        "results/baseline_q{fdr}_{gwas}_p.txt"
    shell:
        "Rscript ../R/AddPvalue.R {input} {output}"
